{
  "name": "AME RAG Agent - V3 SMART (Fast Fail)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "rag-chat-v3-smart",
        "responseMode": "responseNode",
        "options": {"allowedOrigins": "*"}
      },
      "id": "webhook-001",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [100, 300],
      "webhookId": "rag-smart-v3"
    },
    {
      "parameters": {
        "jsCode": "const body = $input.first().json.body || $input.first().json;\nconst query = body.query || body.chatInput || '';\n\nif (!query || query.trim().length === 0) {\n  return [{\n    json: {\n      error: true,\n      error_type: 'empty_query',\n      answer: 'Please provide a query to search the documentation.',\n      suggestions: ['Try asking a specific question about your system'],\n      user_id: body.user_id || body.userId || 'anonymous',\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst conversation_id = body.conversation_id || null;\nconst isGreeting = /^(hi|hello|hey|good morning|good afternoon)/i.test(query.trim());\nconst hasTechnicalTerms = /\\b(span|block|gpm|pump|valve|sensor|controller|wire|wiring|component|module|analog|digital|bacnet|niagara|kitcontrol|honeywell|pid|loop|setpoint|damper|actuator|point|extension)\\b/i.test(query);\nconst wantsVisuals = /\\b(show|image|diagram|picture|visual|schematic|wiring|drawing|illustration|graphic)\\b/i.test(query) || /wir(e|ing)/i.test(query);\nconst wantsDetails = /\\b(detailed|spec|specification|table|parameter|configuration|breakdown|setting|value)\\b/i.test(query);\nconst wordCount = query.split(/\\s+/).length;\nconst isVeryShort = wordCount < 3;\nconst isShort = wordCount < 5;\n\nreturn [{\n  json: {\n    query,\n    conversation_id,\n    isGreeting,\n    hasTechnicalTerms,\n    wantsVisuals,\n    wantsDetails,\n    wordCount,\n    isVeryShort,\n    isShort,\n    doc_id: body.doc_id || null,\n    user_id: body.user_id || body.userId || 'anonymous',\n    username: body.username || 'User',\n    error: false\n  }\n}];"
      },
      "id": "analyzer-001",
      "name": "1. Query Analyzer",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [300, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{"value1": "={{ $json.error }}", "value2": false}]
        }
      },
      "id": "error-check-001",
      "name": "1a. Has Error?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [500, 300]
    },
    {
      "parameters": {
        "conditions": {
          "string": [{"value1": "={{ $json.isGreeting }}", "value2": "true"}]
        }
      },
      "id": "greeting-check-001",
      "name": "2. Is Greeting?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [700, 400]
    },
    {
      "parameters": {
        "jsCode": "const analyzer = $input.first().json;\n\nreturn [{\n  json: {\n    answer: \"Hello! I'm your technical documentation assistant. I can help with BACnet, Niagara, KitControl, HVAC systems, and more. What would you like to know?\",\n    citations: [],\n    images: [],\n    tables: [],\n    golden_chunks: [],\n    metadata: {\n      timestamp: new Date().toISOString(),\n      queryType: 'greeting',\n      query: analyzer.query,\n      user_id: analyzer.user_id,\n      username: analyzer.username\n    },\n    debug: {\n      pipeline: 'greeting-shortcut',\n      executionPath: 'fast-path',\n      nodes_executed: 3,\n      api_calls: 0,\n      cost: 0\n    }\n  }\n}];"
      },
      "id": "greeting-response-001",
      "name": "Greeting Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "jsCode": "const analyzer = $input.first().json;\nconst query = analyzer.query;\nconst issues = [];\nconst suggestions = [];\n\nconst vaguePronounPattern = /\\b(it|this|that|they|these|those)\\b/i;\nif (vaguePronounPattern.test(query) && analyzer.wordCount < 8) {\n  issues.push({\n    type: 'vague_pronoun',\n    severity: 'high',\n    message: 'Your query contains pronouns like \"it\" or \"this\" without clear context.'\n  });\n  suggestions.push('Please specify what component or system you\\'re referring to');\n  suggestions.push('Example: Instead of \"How does it work?\" try \"How does the KitControl PID loop work?\"');\n}\n\nif (analyzer.isVeryShort && !analyzer.hasTechnicalTerms) {\n  issues.push({\n    type: 'too_vague',\n    severity: 'high',\n    message: 'Your query is very short and lacks technical details.'\n  });\n  suggestions.push('Please provide more context about what you need help with');\n  suggestions.push('What system are you working with? (KitControl, BACnet, Niagara, etc.)');\n  suggestions.push('What specific task are you trying to accomplish?');\n}\n\nconst ambiguousTerms = {\n  'pump': ['Which type of pump?', 'Examples: circulation pump, heat pump, condensate pump, water pump'],\n  'valve': ['Which type of valve?', 'Examples: control valve, modulating valve, solenoid valve, ball valve'],\n  'sensor': ['Which type of sensor?', 'Examples: temperature sensor, pressure sensor, humidity sensor, flow sensor'],\n  'loop': ['Which type of loop?', 'Examples: PID loop, control loop, feedback loop, HVAC loop'],\n  'point': ['Which type of point?', 'Examples: analog point, digital point, control point, setpoint'],\n  'controller': ['Which controller?', 'Examples: KitControl, BACnet controller, DDC controller'],\n  'output': ['Which output?', 'Examples: analog output, digital output, control output, AO, DO']\n};\n\nfor (const [term, hints] of Object.entries(ambiguousTerms)) {\n  const termRegex = new RegExp(`\\\\b${term}\\\\b`, 'i');\n  if (termRegex.test(query) && !query.match(/\\b(which|what type|what kind|pid|analog|digital|control|modulating|temperature|pressure|humidity|flow)\\b/i)) {\n    issues.push({\n      type: 'ambiguous_term',\n      severity: 'medium',\n      term: term,\n      message: hints[0]\n    });\n    suggestions.push(hints[1]);\n  }\n}\n\nconst hasAction = /\\b(how|configure|wire|install|setup|troubleshoot|connect|set|adjust|calibrate|test|check|diagnose|repair|replace)\\b/i.test(query);\nconst hasQuestion = /\\b(what|where|when|why|which|who)\\b/i.test(query) || query.includes('?');\n\nif (!hasAction && !hasQuestion && analyzer.wordCount < 6) {\n  issues.push({\n    type: 'unclear_intent',\n    severity: 'medium',\n    message: 'It\\'s unclear what you want to know or do.'\n  });\n  suggestions.push('Try phrasing as a question or describing what you want to accomplish');\n  suggestions.push('Examples: \"How to...\", \"What is...\", \"Where can I find...\"');\n}\n\nconst needsClarification = issues.filter(i => i.severity === 'high').length > 0;\n\nreturn [{\n  json: {\n    ...analyzer,\n    validation: {\n      needs_clarification: needsClarification,\n      issues,\n      suggestions,\n      validated_query: query\n    }\n  }\n}];"
      },
      "id": "query-validator-001",
      "name": "3. Query Validator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 500]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{"value1": "={{ $json.validation.needs_clarification }}", "value2": true}]
        }
      },
      "id": "clarification-check-001",
      "name": "4. Needs Clarification?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1100, 500]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst validation = data.validation;\n\nreturn [{\n  json: {\n    answer: \"I need more information to provide an accurate answer.\",\n    clarification_needed: true,\n    original_query: data.query,\n    issues: validation.issues,\n    suggestions: validation.suggestions,\n    helpful_examples: [\n      \"How to configure KitControl PID loop for temperature control?\",\n      \"What are the wiring specifications for analog output to pump?\",\n      \"Show me the diagram for BACnet network topology\",\n      \"Where is the setpoint parameter in the loop configuration?\"\n    ],\n    metadata: {\n      timestamp: new Date().toISOString(),\n      queryType: 'clarification_request',\n      user_id: data.user_id,\n      username: data.username\n    },\n    debug: {\n      pipeline: 'query-clarification',\n      nodes_executed: 5,\n      api_calls: 0,\n      cost: 0\n    }\n  }\n}];"
      },
      "id": "query-clarification-response-001",
      "name": "Query Clarification Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 400]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst query = data.query;\nconst conversation_id = data.conversation_id;\nconst doc_id = data.doc_id;\n\nconst conversationContext = {\n  id: conversation_id || `conv_${Date.now()}`,\n  user_id: data.user_id,\n  current_doc: doc_id,\n  previous_queries: [],\n  accumulated_context: {\n    detected_system: null,\n    detected_topic: null,\n    relevant_sections: []\n  }\n};\n\nlet enhanced_query = query;\nif (conversationContext.accumulated_context.detected_system) {\n  enhanced_query = `${conversationContext.accumulated_context.detected_system} ${query}`;\n}\n\nreturn [{\n  json: {\n    ...data,\n    conversation: conversationContext,\n    enhanced_query: enhanced_query,\n    search_params: {\n      top_k: 50,\n      fts_weight: data.hasTechnicalTerms ? 0.6 : 0.4,\n      vector_weight: data.hasTechnicalTerms ? 0.4 : 0.6\n    }\n  }\n}];"
      },
      "id": "conversation-state-001",
      "name": "5. Conversation State Manager",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1300, 600]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a technical documentation search expert. Generate 5 alternative search queries for the following technical query.\n\nOriginal Query: \"{{ $json.enhanced_query }}\"\n\nRequirements:\n1. Use different technical terminology and synonyms\n2. Focus on different aspects: configuration, wiring, troubleshooting, specifications, installation\n3. Include related technical terms and component names\n4. Maintain technical accuracy\n5. Each query should be 5-15 words\n\nReturn ONLY a JSON array (no markdown, no explanation):\n[\"query1\", \"query2\", \"query3\", \"query4\", \"query5\"]\n\nExamples:\n\nOriginal: \"How to configure PID loop for temperature control?\"\nOutput: [\n  \"pid loop temperature control configuration settings parameters\",\n  \"proportional integral derivative loop setup temperature sensor\",\n  \"configure loop point temperature control setpoint tuning\",\n  \"pid controller temperature regulation configuration guide\",\n  \"loop configuration temperature control proportional gain integral\"\n]\n\nNow generate 5 variations:"
      },
      "id": "multi-query-gen-001",
      "name": "6. Multi-Query Generator",
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.4,
      "position": [1500, 600]
    },
    {
      "parameters": {
        "options": {"maxTokens": 300, "temperature": 0.5}
      },
      "id": "multi-query-model-001",
      "name": "Multi-Query Model (GPT-4o-mini)",
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1,
      "position": [1500, 800],
      "credentials": {
        "openAiApi": {"id": "mgPrUpycCy78WBt2", "name": "OpenAi account"}
      }
    },
    {
      "parameters": {
        "jsCode": "const llmOutput = $input.first().json;\nconst originalData = $('5. Conversation State Manager').first().json;\n\nlet queries = [];\n\nif (llmOutput.response) {\n  const responseText = llmOutput.response;\n  const jsonMatch = responseText.match(/\\[[\\s\\S]*\\]/);\n  if (jsonMatch) {\n    try {\n      queries = JSON.parse(jsonMatch[0]);\n    } catch (e) {\n      console.log('Multi-query parsing failed, using fallback');\n      queries = [originalData.enhanced_query].concat(Array(4).fill(originalData.enhanced_query));\n    }\n  } else {\n    queries = [originalData.enhanced_query].concat(Array(4).fill(originalData.enhanced_query));\n  }\n} else if (Array.isArray(llmOutput)) {\n  queries = llmOutput;\n} else {\n  queries = [originalData.enhanced_query].concat(Array(4).fill(originalData.enhanced_query));\n}\n\nif (queries.length < 5) {\n  while (queries.length < 5) {\n    queries.push(originalData.enhanced_query);\n  }\n} else if (queries.length > 5) {\n  queries = queries.slice(0, 5);\n}\n\nreturn [{\n  json: {\n    ...originalData,\n    query_variations: queries,\n    multi_query_debug: {\n      original_query: originalData.query,\n      enhanced_query: originalData.enhanced_query,\n      generated_count: queries.length\n    }\n  }\n}];"
      },
      "id": "multi-query-parser-001",
      "name": "7. Parse Multi-Query Output",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1700, 600]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst queries = data.query_variations;\nconst searchParams = data.search_params;\nconst doc_ids = data.doc_id ? [data.doc_id] : null;\n\nreturn queries.map((query, index) => ({\n  json: {\n    query: query,\n    query_index: index,\n    doc_ids: doc_ids,\n    top_k: searchParams.top_k,\n    fts_weight: searchParams.fts_weight,\n    vector_weight: searchParams.vector_weight,\n    original_data: data\n  }\n}));"
      },
      "id": "parallel-multi-search-001",
      "name": "8. Parallel Multi-Search Setup",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1900, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://dwisbglrutplhcotbehy.supabase.co/functions/v1/hybrid-search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  query: $json.query,\n  doc_ids: $json.doc_ids,\n  top_k: $json.top_k,\n  fts_weight: $json.fts_weight,\n  vector_weight: $json.vector_weight\n}) }}",
        "options": {}
      },
      "id": "execute-hybrid-search-001",
      "name": "9. Execute Hybrid Search (5x Parallel)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2100, 600],
      "credentials": {
        "supabaseApi": {"id": "wIbJSxriBymUSxSs", "name": "Supabase - Discourse"}
      }
    },
    {
      "parameters": {
        "jsCode": "const allSearchResults = $input.all();\nconst originalData = allSearchResults[0].json.original_data;\n\nconst multiQueryResults = allSearchResults\n  .filter(item => item.json && !item.json.error && item.json.chunks)\n  .map(item => item.json.chunks || []);\n\nif (multiQueryResults.length === 0) {\n  console.log('All search queries failed or returned empty results');\n  return [{\n    json: {\n      error: true,\n      error_type: 'all_searches_failed',\n      answer: 'I couldn\\'t find any relevant information in the documentation for your query.',\n      suggestions: [\n        'Try rephrasing your query with more specific technical terms',\n        'Check if you\\'re searching in the correct document',\n        'Verify that documents have been uploaded and processed',\n        'Example: Instead of \"configure pump\" try \"configure KitControl circulation pump wiring specifications\"'\n      ],\n      original_query: originalData.query,\n      user_id: originalData.user_id,\n      timestamp: new Date().toISOString(),\n      debug: {\n        pipeline: 'search-failed',\n        total_searches: allSearchResults.length,\n        successful_searches: 0\n      }\n    }\n  }];\n}\n\nfunction reciprocalRankFusion(multiQueryResults, k = 60) {\n  const chunkScores = new Map();\n\n  multiQueryResults.forEach((queryResults, queryIdx) => {\n    queryResults.forEach((chunk, rank) => {\n      const chunkId = chunk.id;\n      const rrfScore = 1 / (k + rank + 1);\n\n      if (!chunkScores.has(chunkId)) {\n        chunkScores.set(chunkId, {\n          chunk: chunk,\n          rrfScore: 0,\n          appearances: 0,\n          queryAppearances: [],\n          ranks: [],\n          originalScores: []\n        });\n      }\n\n      const entry = chunkScores.get(chunkId);\n      entry.rrfScore += rrfScore;\n      entry.appearances++;\n      entry.queryAppearances.push(queryIdx);\n      entry.ranks.push(rank);\n      entry.originalScores.push(chunk.score || 0);\n    });\n  });\n\n  const fusedResults = Array.from(chunkScores.values())\n    .map(entry => ({\n      ...entry.chunk,\n      rrf_score: entry.rrfScore,\n      query_appearances: entry.appearances,\n      avg_rank: entry.ranks.reduce((a, b) => a + b, 0) / entry.ranks.length,\n      query_indices: entry.queryAppearances\n    }))\n    .sort((a, b) => b.rrf_score - a.rrf_score);\n\n  return fusedResults;\n}\n\nconst fusedChunks = reciprocalRankFusion(multiQueryResults);\n\nif (fusedChunks.length === 0) {\n  console.log('RRF produced no results');\n  return [{\n    json: {\n      error: true,\n      error_type: 'no_results_after_fusion',\n      answer: 'No matching content found after searching the documentation.',\n      suggestions: [\n        'Try using different keywords or technical terms',\n        'Simplify your query to focus on one specific topic',\n        'Check if the information might be in a different document'\n      ],\n      original_query: originalData.query,\n      user_id: originalData.user_id,\n      timestamp: new Date().toISOString(),\n      debug: {\n        pipeline: 'fusion-failed',\n        searches_attempted: multiQueryResults.length\n      }\n    }\n  }];\n}\n\nconst top50ForReranking = fusedChunks.slice(0, 50);\n\nreturn [{\n  json: {\n    ...originalData,\n    fused_chunks: top50ForReranking,\n    fusion_stats: {\n      total_unique_chunks: fusedChunks.length,\n      queries_executed: multiQueryResults.length,\n      top_chunk_appearances: top50ForReranking[0]?.query_appearances || 0,\n      chunks_for_reranking: top50ForReranking.length,\n      successful_searches: multiQueryResults.length,\n      total_searches: allSearchResults.length\n    },\n    error: false\n  }\n}];"
      },
      "id": "reciprocal-rank-fusion-001",
      "name": "10. Reciprocal Rank Fusion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2300, 600]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [{"value1": "={{ $json.error }}", "value2": false}]
        }
      },
      "id": "rrf-success-check-001",
      "name": "10a. RRF Success?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2500, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.cohere.ai/v1/rerank",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "cohereApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {"name": "Content-Type", "value": "application/json"},
            {"name": "Accept", "value": "application/json"}
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": \"rerank-english-v3.0\",\n  \"query\": $json.enhanced_query,\n  \"documents\": $json.fused_chunks.map(c => c.content),\n  \"top_n\": 15,\n  \"return_documents\": false\n} }}",
        "options": {}
      },
      "id": "cross-encoder-rerank-001",
      "name": "11. Cross-Encoder Reranking (Cohere)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [2700, 700],
      "credentials": {
        "cohereApi": {"id": "COHERE_CREDENTIAL_ID", "name": "Cohere API"}
      }
    },
    {
      "parameters": {
        "jsCode": "const rerankResponse = $input.first().json;\nconst previousData = $('10. Reciprocal Rank Fusion').first().json;\nconst fusedChunks = previousData.fused_chunks;\n\nif (rerankResponse.error || rerankResponse.message || !rerankResponse.results) {\n  console.log(`Cohere reranking failed: ${rerankResponse.message || rerankResponse.error || 'Unknown error'}. Using RRF results as fallback.`);\n  \n  const fallbackChunks = fusedChunks.slice(0, 15).map((chunk, idx) => ({\n    ...chunk,\n    rerank_score: chunk.rrf_score,\n    rerank_rank: idx,\n    final_rank: idx,\n    reranked: false\n  }));\n  \n  return [{\n    json: {\n      ...previousData,\n      reranked_chunks: fallbackChunks,\n      reranking_stats: {\n        reranking_failed: true,\n        fallback_used: true,\n        error_message: rerankResponse.message || rerankResponse.error || 'Unknown error',\n        input_chunks: fusedChunks.length,\n        output_chunks: fallbackChunks.length,\n        top_rerank_score: fallbackChunks[0]?.rerank_score || 0\n      }\n    }\n  }];\n}\n\nif (!Array.isArray(rerankResponse.results) || rerankResponse.results.length === 0) {\n  console.log('Cohere returned empty results. Using RRF results as fallback.');\n  \n  const fallbackChunks = fusedChunks.slice(0, 15).map((chunk, idx) => ({\n    ...chunk,\n    rerank_score: chunk.rrf_score,\n    rerank_rank: idx,\n    final_rank: idx,\n    reranked: false\n  }));\n  \n  return [{\n    json: {\n      ...previousData,\n      reranked_chunks: fallbackChunks,\n      reranking_stats: {\n        reranking_failed: true,\n        fallback_used: true,\n        error_message: 'Empty results from Cohere',\n        input_chunks: fusedChunks.length,\n        output_chunks: fallbackChunks.length,\n        top_rerank_score: fallbackChunks[0]?.rerank_score || 0\n      }\n    }\n  }];\n}\n\nconst rerankedChunks = rerankResponse.results.map(result => ({\n  ...fusedChunks[result.index],\n  rerank_score: result.relevance_score,\n  rerank_rank: result.index,\n  final_rank: result.index,\n  reranked: true\n}));\n\nreturn [{\n  json: {\n    ...previousData,\n    reranked_chunks: rerankedChunks,\n    reranking_stats: {\n      reranking_failed: false,\n      input_chunks: fusedChunks.length,\n      output_chunks: rerankedChunks.length,\n      top_rerank_score: rerankedChunks[0]?.rerank_score || 0\n    }\n  }\n}];"
      },
      "id": "process-reranked-001",
      "name": "12. Process Reranked Results",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2900, 700]
    },
    {
      "parameters": {
        "jsCode": "const data = $input.first().json;\nconst rerankedChunks = data.reranked_chunks;\n\nif (!rerankedChunks || rerankedChunks.length === 0) {\n  console.log('No reranked chunks available');\n  return [{\n    json: {\n      error: true,\n      error_type: 'no_reranked_chunks',\n      answer: 'Search completed but no relevant chunks were identified.',\n      suggestions: ['Try a different query approach'],\n      timestamp: new Date().toISOString()\n    }\n  }];\n}\n\nconst goldenChunks = rerankedChunks.slice(0, 10).map((c, idx) => ({\n  id: c.id,\n  doc_id: c.doc_id,\n  page: c.page_number,\n  section: c.section_path ? c.section_path.join(' > ') : 'Unknown',\n  section_id: c.section_id,\n  score: c.rerank_score,\n  rank: idx + 1,\n  rrf_score: c.rrf_score,\n  query_appearances: c.query_appearances,\n  preview: c.content.substring(0, 200),\n  full_content: c.content\n}));\n\nconst backupChunks = rerankedChunks.slice(10, 15);\nconst chunk_ids = goldenChunks.map(c => c.id);\nconst doc_id = goldenChunks[0]?.doc_id || data.doc_id || null;\n\nif (!doc_id) {\n  console.warn('Warning: No doc_id found in golden chunks or request data');\n}\n\nreturn [{\n  json: {\n    ...data,\n    chunk_ids,\n    doc_id,\n    golden_chunks: goldenChunks,\n    backup_chunks: backupChunks,\n    chunks_count: rerankedChunks.length,\n    error: false\n  }\n}];"
      },
      "id": "extract-golden-chunks-001",
      "name": "13. Extract Golden Chunks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3100, 700]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {}
      },
      "id": "respond-webhook-001",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3300, 500]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [[{"node": "1. Query Analyzer", "type": "main", "index": 0}]]
    },
    "1. Query Analyzer": {
      "main": [[{"node": "1a. Has Error?", "type": "main", "index": 0}]]
    },
    "1a. Has Error?": {
      "main": [
        [{"node": "Respond to Webhook", "type": "main", "index": 0}],
        [{"node": "2. Is Greeting?", "type": "main", "index": 0}]
      ]
    },
    "2. Is Greeting?": {
      "main": [
        [{"node": "Greeting Response", "type": "main", "index": 0}],
        [{"node": "3. Query Validator", "type": "main", "index": 0}]
      ]
    },
    "Greeting Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "3. Query Validator": {
      "main": [[{"node": "4. Needs Clarification?", "type": "main", "index": 0}]]
    },
    "4. Needs Clarification?": {
      "main": [
        [{"node": "Query Clarification Response", "type": "main", "index": 0}],
        [{"node": "5. Conversation State Manager", "type": "main", "index": 0}]
      ]
    },
    "Query Clarification Response": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    },
    "5. Conversation State Manager": {
      "main": [[{"node": "6. Multi-Query Generator", "type": "main", "index": 0}]]
    },
    "6. Multi-Query Generator": {
      "main": [[{"node": "7. Parse Multi-Query Output", "type": "main", "index": 0}]]
    },
    "Multi-Query Model (GPT-4o-mini)": {
      "ai_languageModel": [[{"node": "6. Multi-Query Generator", "type": "ai_languageModel", "index": 0}]]
    },
    "7. Parse Multi-Query Output": {
      "main": [[{"node": "8. Parallel Multi-Search Setup", "type": "main", "index": 0}]]
    },
    "8. Parallel Multi-Search Setup": {
      "main": [[{"node": "9. Execute Hybrid Search (5x Parallel)", "type": "main", "index": 0}]]
    },
    "9. Execute Hybrid Search (5x Parallel)": {
      "main": [[{"node": "10. Reciprocal Rank Fusion", "type": "main", "index": 0}]]
    },
    "10. Reciprocal Rank Fusion": {
      "main": [[{"node": "10a. RRF Success?", "type": "main", "index": 0}]]
    },
    "10a. RRF Success?": {
      "main": [
        [{"node": "Respond to Webhook", "type": "main", "index": 0}],
        [{"node": "11. Cross-Encoder Reranking (Cohere)", "type": "main", "index": 0}]
      ]
    },
    "11. Cross-Encoder Reranking (Cohere)": {
      "main": [[{"node": "12. Process Reranked Results", "type": "main", "index": 0}]]
    },
    "12. Process Reranked Results": {
      "main": [[{"node": "13. Extract Golden Chunks", "type": "main", "index": 0}]]
    },
    "13. Extract Golden Chunks": {
      "main": [[{"node": "Respond to Webhook", "type": "main", "index": 0}]]
    }
  },
  "meta": {
    "templateCredsSetupCompleted": false,
    "instanceId": "rag-smart-v3"
  },
  "tags": [
    {
      "createdAt": "2025-11-15T04:00:00.000Z",
      "updatedAt": "2025-11-15T04:00:00.000Z",
      "id": "1",
      "name": "production"
    }
  ]
}
